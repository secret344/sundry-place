# 滑动窗口

TCP 是一个可靠的协议，每发送一个数据，都要进行一次确认应答。上一个包数据收到了，在发送下一个数据。但是这种方式是非常低效的，当往返时间越长就会导致效率越低，为了解决这个问题引入了窗口概念。

有窗口就可以指定窗口大小，TCP 的 Window 是一个 16bit 位字段，它代表的是窗口的字节容量，也就是 TCP 的标准窗口最大为 2^16-1=65535 个字节。

## 基本原理

1. 对于 TCP 的发送方的窗口，任何时候缓存在内的数据都可以分为 4 类：

    - 已发送并受到 ACK 确认
    - 已发送未收到 ACK 确认
    - 未发送但是允许发送的
    - 未发送但超过接收方处理大小的

假设，当发送方发送完“全部”数据，可用窗口大小为 0，表明可用窗口耗尽，没收到 ACK 之前是无法继续发送数据了。

> 发送窗口计算：

-   SND.WND

表示发送窗口大小。（接收方定义）

-   SND.UNA

一个绝对指针，指向已发送未收到 ACK 确认范围的第一个序号。

-   SND.NXT

一个绝对指针，指向未发送可发送范围的第一个序号。

> 由此： 发送方窗口大小 = SND.WND ； 可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)； 未发送超过范围第一个序号 = SND.UNX + SND.WND

1. 对于 TCP 的接收方的窗口,分为 3 类：
    - 已接受并确认
    - 未收到但可以接收的（ACK 由 TCP 协议回复 默认 0 延迟）
    - 未收到不能接收的

> 接收方窗口计算相对简单:

-   RCV.WND

接收窗口大小，通过 ACK 通知发送方

-   RCV.NXT

指针指向期望从发送放接收的下一个数据字节的序列号

-   未收到不可接收的第一个序号：RCV.WND + RCV.NXT

> 注意，接收方与发送方窗口不一定相等，约等于发送方窗口。

## 流量控制

理想状态下，发送窗口接收窗口整个传输过程都保持相同大小，不受外界影响。但是实际中，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统缓冲区，会被操作系统调整。

1. 当服务器繁忙时，不能及时读取缓存数据，就会导致接收端窗口不断缩小，最终为 0。发生窗口关闭。

2. 当系统资源非常紧张时，操作系统可能会直接减少接收缓冲区大小，这时应用程序无法及时读取数据，就会导致数据包丢失。

此时客户端因为没有接收到服务端窗口改变的 ACK，所以不知道窗口缩小，会继续发送剩余可发送的数据包，当后续发送的包大于此时的接收缓冲区时，就会发生丢包。并且由于应用程序读取首次数据时会通知发送端减少发送窗口，当二次发送数据大小大于修改后的接收端窗口，就会倒是负值出现。

为了防止这种情况，TCP 规定不允许同时减少缓存和窗口，而是先收缩窗口，过段时间在减少缓存，就可以避免丢包。

### 窗口关闭

当窗口为 0 时，就会发生窗口关闭，此时发送方不在发送数据。

窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，就会导致发送方一直等待窗口非 0 的通知，接收方也在等待数据，为了解决这个问题，TCP 为每个链接设定了一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

### 窗口探测

-   如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；
-   如果接收窗口不是 0，那么死锁的局面就可以被打破了。

    窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。

### 糊涂窗口综合症

有时候接收方繁忙，不及时取走缓冲区的数据，就会导致发送端窗口越来越小，最终，如果接收方去除几个字节的数据并告知发送方现在有几个字节的窗口，那么发送方就会发送几个字节的数据，这就是糊涂窗口综合症。

我们知道 TCP+IP 头部有 40 个字节，为了传输几个字节，花的开销过大，很不划算。

糊涂窗口综合症原因在发送方和接收方。

-   接收方可以通告一个小窗口
-   发送方可以发送小数据

所以解决这个问题只需要，让接收方不告知发送方小窗口，发送方避免发送小数据。

1. 怎么让接收方不通告小窗口呢？

当窗口大小小于 min(MSS, 缓存空间/2)，也就是小于 MSS 与 1/2 缓存空间的最小值时，就会告知发送方窗口大小为 0，此时发送方不在发送数据。

等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。

2. 让发送方不再发送小数据

    [纳格(Nagle)算法](https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95)发挥作用。发送方只有以下情况才能发送段

    - 待发送的数据为一个全尺寸段(即接收 MSS)的段。
    - TCP 可以发送大小至少为另一端在此连接上通告的最大窗口大小的一半。避免主机总是通告过小的窗口
    - 纳格算法启动的情况下，TCP 在没有急需 ACK 的数据的情况下，TCP 可以发送任何它必须立即发送的数据。避免 TCP 在有急需 ACK 的数据的情况下还发送比较小的段。如果发送方应用程序一直在往连接写入大小很小的数据

```
    Nagle示例：
 if有新资料发送
   if窗口大小>= MSS and可发送的资料>= MSS
     立即发送MSS大小的segment
   else
    if仍有尚未收到ACK的数据
      在下一个确认（ACK）包收到之前，将资料排到缓冲队列。
    else
      立即发送
```

> 在搭配 TCP 延迟确认时，可能会产生不好的作用，当连续发送两小段数据在跟着读时，接收端收到第一次因为延迟确认而等待第二次写后一并发送 ACK，但是发送方因为第二次数据长度小于 MSS 而等待第一次写的 ACK，最终两端都陷入等待 ACK 超时。TCP 为应用程序提供了一个禁用纳格(Nagle)算法的接口（通常称为 TCP_NODELAY 选项）。用户层面解决方案是避免套接字的写写读序列，换成对 TCP 的小段写，然后一次发送。在每次读之前使用标准的 UNIX I/O 包并冲刷写缓存通常能起作用。
